{
  "version": 3,
  "sources": ["../../node_modules/home-assistant-js-websocket/dist/errors.js", "../../node_modules/home-assistant-js-websocket/dist/messages.js", "../../node_modules/home-assistant-js-websocket/dist/util.js", "../../node_modules/home-assistant-js-websocket/dist/socket.js", "../../node_modules/home-assistant-js-websocket/dist/connection.js", "../../node_modules/home-assistant-js-websocket/dist/auth.js", "../../node_modules/home-assistant-js-websocket/dist/store.js", "../../node_modules/home-assistant-js-websocket/dist/collection.js", "../../node_modules/home-assistant-js-websocket/dist/commands.js", "../../node_modules/home-assistant-js-websocket/dist/config.js", "../../node_modules/home-assistant-js-websocket/dist/services.js", "../../node_modules/home-assistant-js-websocket/dist/entities.js", "../../node_modules/home-assistant-js-websocket/dist/index.js"],
  "sourcesContent": ["export const ERR_CANNOT_CONNECT = 1;\nexport const ERR_INVALID_AUTH = 2;\nexport const ERR_CONNECTION_LOST = 3;\nexport const ERR_HASS_HOST_REQUIRED = 4;\nexport const ERR_INVALID_HTTPS_TO_HTTP = 5;\nexport const ERR_INVALID_AUTH_CALLBACK = 6;\n", "export function auth(accessToken) {\n    return {\n        type: \"auth\",\n        access_token: accessToken,\n    };\n}\nexport function supportedFeatures() {\n    return {\n        type: \"supported_features\",\n        id: 1, // Always the first message after auth\n        features: { coalesce_messages: 1 },\n    };\n}\nexport function states() {\n    return {\n        type: \"get_states\",\n    };\n}\nexport function config() {\n    return {\n        type: \"get_config\",\n    };\n}\nexport function services() {\n    return {\n        type: \"get_services\",\n    };\n}\nexport function user() {\n    return {\n        type: \"auth/current_user\",\n    };\n}\nexport function callService(domain, service, serviceData, target, returnResponse) {\n    const message = {\n        type: \"call_service\",\n        domain,\n        service,\n        target,\n        return_response: returnResponse,\n    };\n    if (serviceData) {\n        message.service_data = serviceData;\n    }\n    return message;\n}\nexport function subscribeEvents(eventType) {\n    const message = {\n        type: \"subscribe_events\",\n    };\n    if (eventType) {\n        message.event_type = eventType;\n    }\n    return message;\n}\nexport function unsubscribeEvents(subscription) {\n    return {\n        type: \"unsubscribe_events\",\n        subscription,\n    };\n}\nexport function ping() {\n    return {\n        type: \"ping\",\n    };\n}\nexport function error(code, message) {\n    return {\n        type: \"result\",\n        success: false,\n        error: {\n            code,\n            message,\n        },\n    };\n}\n", "export function parseQuery(queryString) {\n    const query = {};\n    const items = queryString.split(\"&\");\n    for (let i = 0; i < items.length; i++) {\n        const item = items[i].split(\"=\");\n        const key = decodeURIComponent(item[0]);\n        const value = item.length > 1 ? decodeURIComponent(item[1]) : undefined;\n        query[key] = value;\n    }\n    return query;\n}\n// From: https://davidwalsh.name/javascript-debounce-function\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n// eslint-disable-next-line: ban-types\nexport const debounce = (func, wait, immediate = false) => {\n    let timeout;\n    // @ts-ignore\n    return function (...args) {\n        // @ts-ignore\n        const context = this;\n        const later = () => {\n            timeout = undefined;\n            if (!immediate) {\n                func.apply(context, args);\n            }\n        };\n        const callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n            func.apply(context, args);\n        }\n    };\n};\nexport const atLeastHaVersion = (version, major, minor, patch) => {\n    const [haMajor, haMinor, haPatch] = version.split(\".\", 3);\n    return (Number(haMajor) > major ||\n        (Number(haMajor) === major &&\n            (patch === undefined\n                ? Number(haMinor) >= minor\n                : Number(haMinor) > minor)) ||\n        (patch !== undefined &&\n            Number(haMajor) === major &&\n            Number(haMinor) === minor &&\n            Number(haPatch) >= patch));\n};\n", "/**\n * Create a web socket connection with a Home Assistant instance.\n */\nimport { ERR_INVALID_AUTH, ERR_CANNOT_CONNECT, ERR_HASS_HOST_REQUIRED, } from \"./errors.js\";\nimport * as messages from \"./messages.js\";\nimport { atLeastHaVersion } from \"./util.js\";\nconst DEBUG = false;\nexport const MSG_TYPE_AUTH_REQUIRED = \"auth_required\";\nexport const MSG_TYPE_AUTH_INVALID = \"auth_invalid\";\nexport const MSG_TYPE_AUTH_OK = \"auth_ok\";\nexport function createSocket(options) {\n    if (!options.auth) {\n        throw ERR_HASS_HOST_REQUIRED;\n    }\n    const auth = options.auth;\n    // Start refreshing expired tokens even before the WS connection is open.\n    // We know that we will need auth anyway.\n    let authRefreshTask = auth.expired\n        ? auth.refreshAccessToken().then(() => {\n            authRefreshTask = undefined;\n        }, () => {\n            authRefreshTask = undefined;\n        })\n        : undefined;\n    // Convert from http:// -> ws://, https:// -> wss://\n    const url = auth.wsUrl;\n    if (DEBUG) {\n        console.log(\"[Auth phase] Initializing\", url);\n    }\n    function connect(triesLeft, promResolve, promReject) {\n        if (DEBUG) {\n            console.log(\"[Auth Phase] New connection\", url);\n        }\n        const socket = new WebSocket(url);\n        // If invalid auth, we will not try to reconnect.\n        let invalidAuth = false;\n        const closeMessage = () => {\n            // If we are in error handler make sure close handler doesn't also fire.\n            socket.removeEventListener(\"close\", closeMessage);\n            if (invalidAuth) {\n                promReject(ERR_INVALID_AUTH);\n                return;\n            }\n            // Reject if we no longer have to retry\n            if (triesLeft === 0) {\n                // We never were connected and will not retry\n                promReject(ERR_CANNOT_CONNECT);\n                return;\n            }\n            const newTries = triesLeft === -1 ? -1 : triesLeft - 1;\n            // Try again in a second\n            setTimeout(() => connect(newTries, promResolve, promReject), 1000);\n        };\n        // Auth is mandatory, so we can send the auth message right away.\n        const handleOpen = async (event) => {\n            try {\n                if (auth.expired) {\n                    await (authRefreshTask ? authRefreshTask : auth.refreshAccessToken());\n                }\n                socket.send(JSON.stringify(messages.auth(auth.accessToken)));\n            }\n            catch (err) {\n                // Refresh token failed\n                invalidAuth = err === ERR_INVALID_AUTH;\n                socket.close();\n            }\n        };\n        const handleMessage = async (event) => {\n            const message = JSON.parse(event.data);\n            if (DEBUG) {\n                console.log(\"[Auth phase] Received\", message);\n            }\n            switch (message.type) {\n                case MSG_TYPE_AUTH_INVALID:\n                    invalidAuth = true;\n                    socket.close();\n                    break;\n                case MSG_TYPE_AUTH_OK:\n                    socket.removeEventListener(\"open\", handleOpen);\n                    socket.removeEventListener(\"message\", handleMessage);\n                    socket.removeEventListener(\"close\", closeMessage);\n                    socket.removeEventListener(\"error\", closeMessage);\n                    socket.haVersion = message.ha_version;\n                    if (atLeastHaVersion(socket.haVersion, 2022, 9)) {\n                        socket.send(JSON.stringify(messages.supportedFeatures()));\n                    }\n                    promResolve(socket);\n                    break;\n                default:\n                    if (DEBUG) {\n                        // We already send response to this message when socket opens\n                        if (message.type !== MSG_TYPE_AUTH_REQUIRED) {\n                            console.warn(\"[Auth phase] Unhandled message\", message);\n                        }\n                    }\n            }\n        };\n        socket.addEventListener(\"open\", handleOpen);\n        socket.addEventListener(\"message\", handleMessage);\n        socket.addEventListener(\"close\", closeMessage);\n        socket.addEventListener(\"error\", closeMessage);\n    }\n    return new Promise((resolve, reject) => connect(options.setupRetry, resolve, reject));\n}\n", "/**\n * Connection that wraps a socket and provides an interface to interact with\n * the Home Assistant websocket API.\n */\nimport * as messages from \"./messages.js\";\nimport { ERR_INVALID_AUTH, ERR_CONNECTION_LOST } from \"./errors.js\";\nconst DEBUG = false;\nexport class Connection {\n    constructor(socket, options) {\n        this._handleMessage = (event) => {\n            let messageGroup = JSON.parse(event.data);\n            if (!Array.isArray(messageGroup)) {\n                messageGroup = [messageGroup];\n            }\n            messageGroup.forEach((message) => {\n                if (DEBUG) {\n                    console.log(\"Received\", message);\n                }\n                const info = this.commands.get(message.id);\n                switch (message.type) {\n                    case \"event\":\n                        if (info) {\n                            info.callback(message.event);\n                        }\n                        else {\n                            console.warn(`Received event for unknown subscription ${message.id}. Unsubscribing.`);\n                            this.sendMessagePromise(messages.unsubscribeEvents(message.id)).catch((err) => {\n                                if (DEBUG) {\n                                    console.warn(` Error unsubsribing from unknown subscription ${message.id}`, err);\n                                }\n                            });\n                        }\n                        break;\n                    case \"result\":\n                        // No info is fine. If just sendMessage is used, we did not store promise for result\n                        if (info) {\n                            if (message.success) {\n                                info.resolve(message.result);\n                                // Don't remove subscriptions.\n                                if (!(\"subscribe\" in info)) {\n                                    this.commands.delete(message.id);\n                                }\n                            }\n                            else {\n                                info.reject(message.error);\n                                this.commands.delete(message.id);\n                            }\n                        }\n                        break;\n                    case \"pong\":\n                        if (info) {\n                            info.resolve();\n                            this.commands.delete(message.id);\n                        }\n                        else {\n                            console.warn(`Received unknown pong response ${message.id}`);\n                        }\n                        break;\n                    default:\n                        if (DEBUG) {\n                            console.warn(\"Unhandled message\", message);\n                        }\n                }\n            });\n        };\n        this._handleClose = async () => {\n            const oldCommands = this.commands;\n            // reset to original state except haVersion\n            this.commandId = 1;\n            this.oldSubscriptions = this.commands;\n            this.commands = new Map();\n            this.socket = undefined;\n            // Reject in-flight sendMessagePromise requests\n            oldCommands.forEach((info) => {\n                // We don't cancel subscribeEvents commands in flight\n                // as we will be able to recover them.\n                if (!(\"subscribe\" in info)) {\n                    info.reject(messages.error(ERR_CONNECTION_LOST, \"Connection lost\"));\n                }\n            });\n            if (this.closeRequested) {\n                return;\n            }\n            this.fireEvent(\"disconnected\");\n            // Disable setupRetry, we control it here with auto-backoff\n            const options = Object.assign(Object.assign({}, this.options), { setupRetry: 0 });\n            const reconnect = (tries) => {\n                setTimeout(async () => {\n                    if (this.closeRequested) {\n                        return;\n                    }\n                    if (DEBUG) {\n                        console.log(\"Trying to reconnect\");\n                    }\n                    try {\n                        const socket = await options.createSocket(options);\n                        this._setSocket(socket);\n                    }\n                    catch (err) {\n                        if (this._queuedMessages) {\n                            const queuedMessages = this._queuedMessages;\n                            this._queuedMessages = undefined;\n                            for (const msg of queuedMessages) {\n                                if (msg.reject) {\n                                    msg.reject(ERR_CONNECTION_LOST);\n                                }\n                            }\n                        }\n                        if (err === ERR_INVALID_AUTH) {\n                            this.fireEvent(\"reconnect-error\", err);\n                        }\n                        else {\n                            reconnect(tries + 1);\n                        }\n                    }\n                }, Math.min(tries, 5) * 1000);\n            };\n            if (this.suspendReconnectPromise) {\n                await this.suspendReconnectPromise;\n                this.suspendReconnectPromise = undefined;\n                // For the first retry after suspend, we will queue up\n                // all messages.\n                this._queuedMessages = [];\n            }\n            reconnect(0);\n        };\n        // connection options\n        //  - setupRetry: amount of ms to retry when unable to connect on initial setup\n        //  - createSocket: create a new Socket connection\n        this.options = options;\n        // id if next command to send\n        this.commandId = 2; // socket may send 1 at the start to enable features\n        // info about active subscriptions and commands in flight\n        this.commands = new Map();\n        // map of event listeners\n        this.eventListeners = new Map();\n        // true if a close is requested by the user\n        this.closeRequested = false;\n        this._setSocket(socket);\n    }\n    get connected() {\n        // Using conn.socket.OPEN instead of WebSocket for better node support\n        return (this.socket !== undefined && this.socket.readyState == this.socket.OPEN);\n    }\n    _setSocket(socket) {\n        this.socket = socket;\n        this.haVersion = socket.haVersion;\n        socket.addEventListener(\"message\", this._handleMessage);\n        socket.addEventListener(\"close\", this._handleClose);\n        const oldSubscriptions = this.oldSubscriptions;\n        if (oldSubscriptions) {\n            this.oldSubscriptions = undefined;\n            oldSubscriptions.forEach((info) => {\n                if (\"subscribe\" in info && info.subscribe) {\n                    info.subscribe().then((unsub) => {\n                        info.unsubscribe = unsub;\n                        // We need to resolve this in case it wasn't resolved yet.\n                        // This allows us to subscribe while we're disconnected\n                        // and recover properly.\n                        info.resolve();\n                    });\n                }\n            });\n        }\n        const queuedMessages = this._queuedMessages;\n        if (queuedMessages) {\n            this._queuedMessages = undefined;\n            for (const queuedMsg of queuedMessages) {\n                queuedMsg.resolve();\n            }\n        }\n        this.fireEvent(\"ready\");\n    }\n    addEventListener(eventType, callback) {\n        let listeners = this.eventListeners.get(eventType);\n        if (!listeners) {\n            listeners = [];\n            this.eventListeners.set(eventType, listeners);\n        }\n        listeners.push(callback);\n    }\n    removeEventListener(eventType, callback) {\n        const listeners = this.eventListeners.get(eventType);\n        if (!listeners) {\n            return;\n        }\n        const index = listeners.indexOf(callback);\n        if (index !== -1) {\n            listeners.splice(index, 1);\n        }\n    }\n    fireEvent(eventType, eventData) {\n        (this.eventListeners.get(eventType) || []).forEach((callback) => callback(this, eventData));\n    }\n    suspendReconnectUntil(suspendPromise) {\n        this.suspendReconnectPromise = suspendPromise;\n    }\n    suspend() {\n        if (!this.suspendReconnectPromise) {\n            throw new Error(\"Suspend promise not set\");\n        }\n        if (this.socket) {\n            this.socket.close();\n        }\n    }\n    /**\n     * Reconnect the websocket connection.\n     * @param force discard old socket instead of gracefully closing it.\n     */\n    reconnect(force = false) {\n        if (!this.socket) {\n            return;\n        }\n        if (!force) {\n            this.socket.close();\n            return;\n        }\n        this.socket.removeEventListener(\"message\", this._handleMessage);\n        this.socket.removeEventListener(\"close\", this._handleClose);\n        this.socket.close();\n        this._handleClose();\n    }\n    close() {\n        this.closeRequested = true;\n        if (this.socket) {\n            this.socket.close();\n        }\n    }\n    /**\n     * Subscribe to a specific or all events.\n     *\n     * @param callback Callback  to be called when a new event fires\n     * @param eventType\n     * @returns promise that resolves to an unsubscribe function\n     */\n    async subscribeEvents(callback, eventType) {\n        return this.subscribeMessage(callback, messages.subscribeEvents(eventType));\n    }\n    ping() {\n        return this.sendMessagePromise(messages.ping());\n    }\n    sendMessage(message, commandId) {\n        if (!this.connected) {\n            throw ERR_CONNECTION_LOST;\n        }\n        if (DEBUG) {\n            console.log(\"Sending\", message);\n        }\n        if (this._queuedMessages) {\n            if (commandId) {\n                throw new Error(\"Cannot queue with commandId\");\n            }\n            this._queuedMessages.push({ resolve: () => this.sendMessage(message) });\n            return;\n        }\n        if (!commandId) {\n            commandId = this._genCmdId();\n        }\n        message.id = commandId;\n        this.socket.send(JSON.stringify(message));\n    }\n    sendMessagePromise(message) {\n        return new Promise((resolve, reject) => {\n            if (this._queuedMessages) {\n                this._queuedMessages.push({\n                    reject,\n                    resolve: async () => {\n                        try {\n                            resolve(await this.sendMessagePromise(message));\n                        }\n                        catch (err) {\n                            reject(err);\n                        }\n                    },\n                });\n                return;\n            }\n            const commandId = this._genCmdId();\n            this.commands.set(commandId, { resolve, reject });\n            this.sendMessage(message, commandId);\n        });\n    }\n    /**\n     * Call a websocket command that starts a subscription on the backend.\n     *\n     * @param message the message to start the subscription\n     * @param callback the callback to be called when a new item arrives\n     * @param [options.resubscribe] re-established a subscription after a reconnect. Defaults to true.\n     * @returns promise that resolves to an unsubscribe function\n     */\n    async subscribeMessage(callback, subscribeMessage, options) {\n        if (this._queuedMessages) {\n            await new Promise((resolve, reject) => {\n                this._queuedMessages.push({ resolve, reject });\n            });\n        }\n        if (options === null || options === void 0 ? void 0 : options.preCheck) {\n            const precheck = await options.preCheck();\n            if (!precheck) {\n                throw new Error(\"Pre-check failed\");\n            }\n        }\n        let info;\n        await new Promise((resolve, reject) => {\n            // Command ID that will be used\n            const commandId = this._genCmdId();\n            // We store unsubscribe on info object. That way we can overwrite it in case\n            // we get disconnected and we have to subscribe again.\n            info = {\n                resolve,\n                reject,\n                callback,\n                subscribe: (options === null || options === void 0 ? void 0 : options.resubscribe) !== false\n                    ? () => this.subscribeMessage(callback, subscribeMessage, options)\n                    : undefined,\n                unsubscribe: async () => {\n                    // No need to unsubscribe if we're disconnected\n                    if (this.connected) {\n                        await this.sendMessagePromise(messages.unsubscribeEvents(commandId));\n                    }\n                    this.commands.delete(commandId);\n                },\n            };\n            this.commands.set(commandId, info);\n            try {\n                this.sendMessage(subscribeMessage, commandId);\n            }\n            catch (err) {\n                // Happens when the websocket is already closing.\n                // Don't have to handle the error, reconnect logic will pick it up.\n            }\n        });\n        return () => info.unsubscribe();\n    }\n    _genCmdId() {\n        return ++this.commandId;\n    }\n}\n", "import { parseQuery } from \"./util.js\";\nimport { ERR_HASS_HOST_REQUIRED, ERR_INVALID_AUTH, ERR_INVALID_AUTH_CALLBACK, ERR_INVALID_HTTPS_TO_HTTP, } from \"./errors.js\";\nexport const genClientId = () => `${location.protocol}//${location.host}/`;\nexport const genExpires = (expires_in) => {\n    return expires_in * 1000 + Date.now();\n};\nfunction genRedirectUrl() {\n    // Get current url but without # part.\n    const { protocol, host, pathname, search } = location;\n    return `${protocol}//${host}${pathname}${search}`;\n}\nfunction genAuthorizeUrl(hassUrl, clientId, redirectUrl, state) {\n    let authorizeUrl = `${hassUrl}/auth/authorize?response_type=code&redirect_uri=${encodeURIComponent(redirectUrl)}`;\n    if (clientId !== null) {\n        authorizeUrl += `&client_id=${encodeURIComponent(clientId)}`;\n    }\n    if (state) {\n        authorizeUrl += `&state=${encodeURIComponent(state)}`;\n    }\n    return authorizeUrl;\n}\nfunction redirectAuthorize(hassUrl, clientId, redirectUrl, state) {\n    // Add either ?auth_callback=1 or &auth_callback=1\n    redirectUrl += (redirectUrl.includes(\"?\") ? \"&\" : \"?\") + \"auth_callback=1\";\n    document.location.href = genAuthorizeUrl(hassUrl, clientId, redirectUrl, state);\n}\nasync function tokenRequest(hassUrl, clientId, data) {\n    // Browsers don't allow fetching tokens from https -> http.\n    // Throw an error because it's a pain to debug this.\n    // Guard against not working in node.\n    const l = typeof location !== \"undefined\" && location;\n    if (l && l.protocol === \"https:\") {\n        // Ensure that the hassUrl is hosted on https.\n        const a = document.createElement(\"a\");\n        a.href = hassUrl;\n        if (a.protocol === \"http:\" && a.hostname !== \"localhost\") {\n            throw ERR_INVALID_HTTPS_TO_HTTP;\n        }\n    }\n    const formData = new FormData();\n    if (clientId !== null) {\n        formData.append(\"client_id\", clientId);\n    }\n    Object.keys(data).forEach((key) => {\n        // @ts-ignore\n        formData.append(key, data[key]);\n    });\n    const resp = await fetch(`${hassUrl}/auth/token`, {\n        method: \"POST\",\n        credentials: \"same-origin\",\n        body: formData,\n    });\n    if (!resp.ok) {\n        throw resp.status === 400 /* auth invalid */ ||\n            resp.status === 403 /* user not active */\n            ? ERR_INVALID_AUTH\n            : new Error(\"Unable to fetch tokens\");\n    }\n    const tokens = await resp.json();\n    tokens.hassUrl = hassUrl;\n    tokens.clientId = clientId;\n    tokens.expires = genExpires(tokens.expires_in);\n    return tokens;\n}\nfunction fetchToken(hassUrl, clientId, code) {\n    return tokenRequest(hassUrl, clientId, {\n        code,\n        grant_type: \"authorization_code\",\n    });\n}\nfunction encodeOAuthState(state) {\n    return btoa(JSON.stringify(state));\n}\nfunction decodeOAuthState(encoded) {\n    return JSON.parse(atob(encoded));\n}\nexport class Auth {\n    constructor(data, saveTokens) {\n        this.data = data;\n        this._saveTokens = saveTokens;\n    }\n    get wsUrl() {\n        // Convert from http:// -> ws://, https:// -> wss://\n        return `ws${this.data.hassUrl.substr(4)}/api/websocket`;\n    }\n    get accessToken() {\n        return this.data.access_token;\n    }\n    get expired() {\n        return Date.now() > this.data.expires;\n    }\n    /**\n     * Refresh the access token.\n     */\n    async refreshAccessToken() {\n        if (!this.data.refresh_token)\n            throw new Error(\"No refresh_token\");\n        const data = await tokenRequest(this.data.hassUrl, this.data.clientId, {\n            grant_type: \"refresh_token\",\n            refresh_token: this.data.refresh_token,\n        });\n        // Access token response does not contain refresh token.\n        data.refresh_token = this.data.refresh_token;\n        this.data = data;\n        if (this._saveTokens)\n            this._saveTokens(data);\n    }\n    /**\n     * Revoke the refresh & access tokens.\n     */\n    async revoke() {\n        if (!this.data.refresh_token)\n            throw new Error(\"No refresh_token to revoke\");\n        const formData = new FormData();\n        formData.append(\"token\", this.data.refresh_token);\n        // There is no error checking, as revoke will always return 200\n        await fetch(`${this.data.hassUrl}/auth/revoke`, {\n            method: \"POST\",\n            credentials: \"same-origin\",\n            body: formData,\n        });\n        if (this._saveTokens) {\n            this._saveTokens(null);\n        }\n    }\n}\nexport function createLongLivedTokenAuth(hassUrl, access_token) {\n    return new Auth({\n        hassUrl,\n        clientId: null,\n        expires: Date.now() + 1e11,\n        refresh_token: \"\",\n        access_token,\n        expires_in: 1e11,\n    });\n}\nexport async function getAuth(options = {}) {\n    let data;\n    let hassUrl = options.hassUrl;\n    // Strip trailing slash.\n    if (hassUrl && hassUrl[hassUrl.length - 1] === \"/\") {\n        hassUrl = hassUrl.substr(0, hassUrl.length - 1);\n    }\n    const clientId = options.clientId !== undefined ? options.clientId : genClientId();\n    const limitHassInstance = options.limitHassInstance === true;\n    // Use auth code if it was passed in\n    if (options.authCode && hassUrl) {\n        data = await fetchToken(hassUrl, clientId, options.authCode);\n        if (options.saveTokens) {\n            options.saveTokens(data);\n        }\n    }\n    // Check if we came back from an authorize redirect\n    if (!data) {\n        const query = parseQuery(location.search.substr(1));\n        // Check if we got redirected here from authorize page\n        if (\"auth_callback\" in query) {\n            // Restore state\n            const state = decodeOAuthState(query.state);\n            if (limitHassInstance &&\n                (state.hassUrl !== hassUrl || state.clientId !== clientId)) {\n                throw ERR_INVALID_AUTH_CALLBACK;\n            }\n            data = await fetchToken(state.hassUrl, state.clientId, query.code);\n            if (options.saveTokens) {\n                options.saveTokens(data);\n            }\n        }\n    }\n    // Check for stored tokens\n    if (!data && options.loadTokens) {\n        data = await options.loadTokens();\n    }\n    // If the token is for another url, ignore it\n    if (data && (hassUrl === undefined || data.hassUrl === hassUrl)) {\n        return new Auth(data, options.saveTokens);\n    }\n    if (hassUrl === undefined) {\n        throw ERR_HASS_HOST_REQUIRED;\n    }\n    // If no tokens found but a hassUrl was passed in, let's go get some tokens!\n    redirectAuthorize(hassUrl, clientId, options.redirectUrl || genRedirectUrl(), encodeOAuthState({\n        hassUrl,\n        clientId,\n    }));\n    // Just don't resolve while we navigate to next page\n    return new Promise(() => { });\n}\n", "export const createStore = (state) => {\n    let listeners = [];\n    function unsubscribe(listener) {\n        let out = [];\n        for (let i = 0; i < listeners.length; i++) {\n            if (listeners[i] === listener) {\n                listener = null;\n            }\n            else {\n                out.push(listeners[i]);\n            }\n        }\n        listeners = out;\n    }\n    function setState(update, overwrite) {\n        state = overwrite ? update : Object.assign(Object.assign({}, state), update);\n        let currentListeners = listeners;\n        for (let i = 0; i < currentListeners.length; i++) {\n            currentListeners[i](state);\n        }\n    }\n    /**\n     * An observable state container, returned from {@link createStore}\n     * @name store\n     */\n    return {\n        get state() {\n            return state;\n        },\n        /**\n         * Create a bound copy of the given action function.\n         * The bound returned function invokes action() and persists the result back to the store.\n         * If the return value of `action` is a Promise, the resolved value will be used as state.\n         * @param {Function} action\tAn action of the form `action(state, ...args) -> stateUpdate`\n         * @returns {Function} boundAction()\n         */\n        action(action) {\n            function apply(result) {\n                setState(result, false);\n            }\n            // Note: perf tests verifying this implementation: https://esbench.com/bench/5a295e6299634800a0349500\n            return function () {\n                let args = [state];\n                for (let i = 0; i < arguments.length; i++)\n                    args.push(arguments[i]);\n                // @ts-ignore\n                let ret = action.apply(this, args);\n                if (ret != null) {\n                    return ret instanceof Promise ? ret.then(apply) : apply(ret);\n                }\n            };\n        },\n        /**\n         * Apply a partial state object to the current state, invoking registered listeners.\n         * @param {Object} update\t\t\t\tAn object with properties to be merged into state\n         * @param {Boolean} [overwrite=false]\tIf `true`, update will replace state instead of being merged into it\n         */\n        setState,\n        clearState() {\n            state = undefined;\n        },\n        /**\n         * Register a listener function to be called whenever state is changed. Returns an `unsubscribe()` function.\n         * @param {Function} listener\tA function to call when state changes. Gets passed the new state.\n         * @returns {Function} unsubscribe()\n         */\n        subscribe(listener) {\n            listeners.push(listener);\n            return () => {\n                unsubscribe(listener);\n            };\n        },\n        // /**\n        //  * Remove a previously-registered listener function.\n        //  * @param {Function} listener\tThe callback previously passed to `subscribe()` that should be removed.\n        //  * @function\n        //  */\n        // unsubscribe,\n    };\n};\n", "import { createStore } from \"./store.js\";\n// Time to wait to unsubscribe from updates after last subscriber unsubscribes\nconst UNSUB_GRACE_PERIOD = 5000; // 5 seconds\nconst DEBUG = false;\n/**\n *\n * @param conn connection\n * @param key the key to store it on the connection. Must be unique for each collection.\n * @param fetchCollection fetch the current state. If undefined assumes subscribeUpdates receives current state\n * @param subscribeUpdates subscribe to updates on the current state\n * @returns\n */\nexport const getCollection = (conn, key, fetchCollection, subscribeUpdates, options = { unsubGrace: true }) => {\n    // @ts-ignore\n    if (conn[key]) {\n        // @ts-ignore\n        return conn[key];\n    }\n    let active = 0;\n    let unsubProm;\n    let unsubTimer;\n    let store = createStore();\n    const refresh = () => {\n        if (!fetchCollection) {\n            throw new Error(\"Collection does not support refresh\");\n        }\n        return fetchCollection(conn).then((state) => store.setState(state, true));\n    };\n    const refreshSwallow = () => refresh().catch((err) => {\n        // Swallow errors if socket is connecting, closing or closed.\n        // We will automatically call refresh again when we re-establish the connection.\n        if (conn.connected) {\n            throw err;\n        }\n    });\n    const setupUpdateSubscription = () => {\n        if (unsubTimer !== undefined) {\n            if (DEBUG) {\n                console.log(`Prevented unsubscribe for ${key}`);\n            }\n            clearTimeout(unsubTimer);\n            unsubTimer = undefined;\n            return;\n        }\n        if (DEBUG) {\n            console.log(`Subscribing to ${key}`);\n        }\n        if (subscribeUpdates) {\n            unsubProm = subscribeUpdates(conn, store);\n        }\n        if (fetchCollection) {\n            // Fetch when connection re-established.\n            conn.addEventListener(\"ready\", refreshSwallow);\n            refreshSwallow();\n        }\n        conn.addEventListener(\"disconnected\", handleDisconnect);\n    };\n    const teardownUpdateSubscription = () => {\n        if (DEBUG) {\n            console.log(`Unsubscribing from ${key}`);\n        }\n        unsubTimer = undefined;\n        // Unsubscribe from changes\n        if (unsubProm)\n            unsubProm.then((unsub) => {\n                unsub();\n            });\n        store.clearState();\n        conn.removeEventListener(\"ready\", refresh);\n        conn.removeEventListener(\"disconnected\", handleDisconnect);\n    };\n    const scheduleTeardownUpdateSubscription = () => {\n        if (DEBUG) {\n            console.log(`Scheduling unsubscribing from ${key}`);\n        }\n        unsubTimer = setTimeout(teardownUpdateSubscription, UNSUB_GRACE_PERIOD);\n    };\n    const handleDisconnect = () => {\n        // If we're going to unsubscribe and then lose connection,\n        // just unsubscribe immediately.\n        if (unsubTimer) {\n            clearTimeout(unsubTimer);\n            teardownUpdateSubscription();\n        }\n    };\n    // @ts-ignore\n    conn[key] = {\n        get state() {\n            return store.state;\n        },\n        refresh,\n        subscribe(subscriber) {\n            active++;\n            if (DEBUG) {\n                console.log(`New subscriber for ${key}. Active subscribers: ${active}`);\n            }\n            // If this was the first subscriber, attach collection\n            if (active === 1) {\n                setupUpdateSubscription();\n            }\n            const unsub = store.subscribe(subscriber);\n            if (store.state !== undefined) {\n                // Don't call it right away so that caller has time\n                // to initialize all the things.\n                setTimeout(() => subscriber(store.state), 0);\n            }\n            return () => {\n                unsub();\n                active--;\n                if (DEBUG) {\n                    console.log(`Unsubscribe for ${key}. Active subscribers: ${active}`);\n                }\n                if (!active) {\n                    options.unsubGrace\n                        ? scheduleTeardownUpdateSubscription()\n                        : teardownUpdateSubscription();\n                }\n            };\n        },\n    };\n    // @ts-ignore\n    return conn[key];\n};\n// Legacy name. It gets a collection and subscribes.\nexport const createCollection = (key, fetchCollection, subscribeUpdates, conn, onChange) => getCollection(conn, key, fetchCollection, subscribeUpdates).subscribe(onChange);\n", "import * as messages from \"./messages.js\";\nexport const getStates = (connection) => connection.sendMessagePromise(messages.states());\nexport const getServices = (connection) => connection.sendMessagePromise(messages.services());\nexport const getConfig = (connection) => connection.sendMessagePromise(messages.config());\nexport const getUser = (connection) => connection.sendMessagePromise(messages.user());\nexport const callService = (connection, domain, service, serviceData, target, returnResponse) => connection.sendMessagePromise(messages.callService(domain, service, serviceData, target, returnResponse));\n", "import { getCollection } from \"./collection.js\";\nimport { getConfig } from \"./commands.js\";\nfunction processComponentLoaded(state, event) {\n    if (state === undefined)\n        return null;\n    return {\n        components: state.components.concat(event.data.component),\n    };\n}\nconst fetchConfig = (conn) => getConfig(conn);\nconst subscribeUpdates = (conn, store) => Promise.all([\n    conn.subscribeEvents(store.action(processComponentLoaded), \"component_loaded\"),\n    conn.subscribeEvents(() => fetchConfig(conn).then((config) => store.setState(config, true)), \"core_config_updated\"),\n]).then((unsubs) => () => unsubs.forEach((unsub) => unsub()));\nexport const configColl = (conn) => getCollection(conn, \"_cnf\", fetchConfig, subscribeUpdates);\nexport const subscribeConfig = (conn, onChange) => configColl(conn).subscribe(onChange);\nexport const STATE_NOT_RUNNING = \"NOT_RUNNING\";\nexport const STATE_STARTING = \"STARTING\";\nexport const STATE_RUNNING = \"RUNNING\";\nexport const STATE_STOPPING = \"STOPPING\";\nexport const STATE_FINAL_WRITE = \"FINAL_WRITE\";\n", "import { getCollection } from \"./collection.js\";\nimport { getServices } from \"./commands.js\";\nimport { debounce } from \"./util.js\";\nfunction processServiceRegistered(conn, store, event) {\n    var _a;\n    const state = store.state;\n    if (state === undefined)\n        return;\n    const { domain, service } = event.data;\n    if (!((_a = state.domain) === null || _a === void 0 ? void 0 : _a.service)) {\n        const domainInfo = Object.assign(Object.assign({}, state[domain]), { [service]: { description: \"\", fields: {} } });\n        store.setState({ [domain]: domainInfo });\n    }\n    debouncedFetchServices(conn, store);\n}\nfunction processServiceRemoved(state, event) {\n    if (state === undefined)\n        return null;\n    const { domain, service } = event.data;\n    const curDomainInfo = state[domain];\n    if (!curDomainInfo || !(service in curDomainInfo))\n        return null;\n    const domainInfo = {};\n    Object.keys(curDomainInfo).forEach((sKey) => {\n        if (sKey !== service)\n            domainInfo[sKey] = curDomainInfo[sKey];\n    });\n    return { [domain]: domainInfo };\n}\nconst debouncedFetchServices = debounce((conn, store) => fetchServices(conn).then((services) => store.setState(services, true)), 5000);\nconst fetchServices = (conn) => getServices(conn);\nconst subscribeUpdates = (conn, store) => Promise.all([\n    conn.subscribeEvents((ev) => processServiceRegistered(conn, store, ev), \"service_registered\"),\n    conn.subscribeEvents(store.action(processServiceRemoved), \"service_removed\"),\n]).then((unsubs) => () => unsubs.forEach((fn) => fn()));\nexport const servicesColl = (conn) => getCollection(conn, \"_srv\", fetchServices, subscribeUpdates);\nexport const subscribeServices = (conn, onChange) => servicesColl(conn).subscribe(onChange);\n", "import { getCollection } from \"./collection.js\";\nimport { getStates } from \"./commands.js\";\nimport { atLeastHaVersion } from \"./util.js\";\nfunction processEvent(store, updates) {\n    const state = Object.assign({}, store.state);\n    if (updates.a) {\n        for (const entityId in updates.a) {\n            const newState = updates.a[entityId];\n            let last_changed = new Date(newState.lc * 1000).toISOString();\n            state[entityId] = {\n                entity_id: entityId,\n                state: newState.s,\n                attributes: newState.a,\n                context: typeof newState.c === \"string\"\n                    ? { id: newState.c, parent_id: null, user_id: null }\n                    : newState.c,\n                last_changed: last_changed,\n                last_updated: newState.lu\n                    ? new Date(newState.lu * 1000).toISOString()\n                    : last_changed,\n            };\n        }\n    }\n    if (updates.r) {\n        for (const entityId of updates.r) {\n            delete state[entityId];\n        }\n    }\n    if (updates.c) {\n        for (const entityId in updates.c) {\n            let entityState = state[entityId];\n            if (!entityState) {\n                console.warn(\"Received state update for unknown entity\", entityId);\n                continue;\n            }\n            entityState = Object.assign({}, entityState);\n            const { \"+\": toAdd, \"-\": toRemove } = updates.c[entityId];\n            const attributesChanged = (toAdd === null || toAdd === void 0 ? void 0 : toAdd.a) || (toRemove === null || toRemove === void 0 ? void 0 : toRemove.a);\n            const attributes = attributesChanged\n                ? Object.assign({}, entityState.attributes) : entityState.attributes;\n            if (toAdd) {\n                if (toAdd.s !== undefined) {\n                    entityState.state = toAdd.s;\n                }\n                if (toAdd.c) {\n                    if (typeof toAdd.c === \"string\") {\n                        entityState.context = Object.assign(Object.assign({}, entityState.context), { id: toAdd.c });\n                    }\n                    else {\n                        entityState.context = Object.assign(Object.assign({}, entityState.context), toAdd.c);\n                    }\n                }\n                if (toAdd.lc) {\n                    entityState.last_updated = entityState.last_changed = new Date(toAdd.lc * 1000).toISOString();\n                }\n                else if (toAdd.lu) {\n                    entityState.last_updated = new Date(toAdd.lu * 1000).toISOString();\n                }\n                if (toAdd.a) {\n                    Object.assign(attributes, toAdd.a);\n                }\n            }\n            if (toRemove === null || toRemove === void 0 ? void 0 : toRemove.a) {\n                for (const key of toRemove.a) {\n                    delete attributes[key];\n                }\n            }\n            if (attributesChanged) {\n                entityState.attributes = attributes;\n            }\n            state[entityId] = entityState;\n        }\n    }\n    store.setState(state, true);\n}\nconst subscribeUpdates = (conn, store) => conn.subscribeMessage((ev) => processEvent(store, ev), {\n    type: \"subscribe_entities\",\n});\nfunction legacyProcessEvent(store, event) {\n    const state = store.state;\n    if (state === undefined)\n        return;\n    const { entity_id, new_state } = event.data;\n    if (new_state) {\n        store.setState({ [new_state.entity_id]: new_state });\n    }\n    else {\n        const newEntities = Object.assign({}, state);\n        delete newEntities[entity_id];\n        store.setState(newEntities, true);\n    }\n}\nasync function legacyFetchEntities(conn) {\n    const states = await getStates(conn);\n    const entities = {};\n    for (let i = 0; i < states.length; i++) {\n        const state = states[i];\n        entities[state.entity_id] = state;\n    }\n    return entities;\n}\nconst legacySubscribeUpdates = (conn, store) => conn.subscribeEvents((ev) => legacyProcessEvent(store, ev), \"state_changed\");\nexport const entitiesColl = (conn) => atLeastHaVersion(conn.haVersion, 2022, 4, 0)\n    ? getCollection(conn, \"_ent\", undefined, subscribeUpdates)\n    : getCollection(conn, \"_ent\", legacyFetchEntities, legacySubscribeUpdates);\nexport const subscribeEntities = (conn, onChange) => entitiesColl(conn).subscribe(onChange);\n", "// JS extensions in imports allow tsc output to be consumed by browsers.\nimport { createSocket } from \"./socket.js\";\nimport { Connection } from \"./connection.js\";\nexport * from \"./auth.js\";\nexport * from \"./collection.js\";\nexport * from \"./connection.js\";\nexport * from \"./config.js\";\nexport * from \"./services.js\";\nexport * from \"./entities.js\";\nexport * from \"./errors.js\";\nexport * from \"./socket.js\";\nexport * from \"./types.js\";\nexport * from \"./commands.js\";\nexport * from \"./store.js\";\nexport async function createConnection(options) {\n    const connOptions = Object.assign({ setupRetry: 0, createSocket }, options);\n    const socket = await connOptions.createSocket(connOptions);\n    const conn = new Connection(socket, connOptions);\n    return conn;\n}\n"],
  "mappings": "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",
  "names": ["auth", "DEBUG", "options", "socket", "DEBUG", "subscribeUpdates", "callService", "config", "services", "subscribeUpdates", "subscribeUpdates", "states"]
}
